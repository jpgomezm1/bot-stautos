const express = require('express');
const axios = require('axios');
const Anthropic = require('@anthropic-ai/sdk');
const multer = require('multer');
require('dotenv').config();

// Importar m√≥dulos locales
const { VehicleConversationEngine } = require('./conversation/vehicleEngine');
const { VehicleDatabase } = require('./database/vehicleSchema');
const { formatPhoneNumber, generateVehicleId, logConversation } = require('./utils/helpers');
const { EmailService } = require('./services/emailService');
const { VehicleSheetsService } = require('./services/vehicleSheetsService');
const { InventoryService } = require('./services/inventoryService');
const { ElevenLabsService } = require('./services/elevenLabsService');
const { GCSService } = require('./services/gcsService');
const { TranscriptionService } = require('./services/transcriptionService');
const { ImageService } = require('./services/imageService');

const app = express();
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ limit: '50mb', extended: true }));

// Configurar multer para archivos
const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB
});

// Configuraci√≥n de Claude
const anthropic = new Anthropic({
  apiKey: process.env.CLAUDE_API_KEY,
});

// Configuraci√≥n de UltraMSG
const ULTRAMSG_TOKEN = process.env.ULTRAMSG_TOKEN;
const INSTANCE_ID = process.env.ULTRAMSG_INSTANCE_ID;
const ULTRAMSG_BASE_URL = `https://api.ultramsg.com/${INSTANCE_ID}`;

// N√∫mero autorizado para usar el bot (puedes cambiarlo seg√∫n necesites)
const AUTHORIZED_NUMBERS = ['573183351733']; // Array para m√∫ltiples n√∫meros autorizados

// Inicializar sistemas
const vehicleConversationEngine = new VehicleConversationEngine();
const vehicleDB = new VehicleDatabase();
const emailService = new EmailService();
const vehicleSheetsService = new VehicleSheetsService();
const inventoryService = new InventoryService();
const elevenLabsService = new ElevenLabsService();
const gcsService = new GCSService();
const transcriptionService = new TranscriptionService();
const imageService = new ImageService();

// Store para conversaciones activas
const activeConversations = new Map();

// Verificaci√≥n de servicios al iniciar
(async () => {
  console.log('üîç Verificando conexi√≥n a Redis...');
  const healthCheck = await vehicleDB.healthCheck();
  console.log('üìä Estado de la base de datos:', healthCheck);
  
  if (healthCheck.redis) {
    console.log('‚úÖ Redis conectado y funcionando');
  } else {
    console.log('‚ö†Ô∏è Redis no disponible - usando memoria como fallback');
  }
  
  // Verificar inventario de veh√≠culos
  console.log('üöó Verificando inventario de veh√≠culos...');
  const inventoryTest = await inventoryService.testConnection();
  if (inventoryTest.success) {
    console.log('‚úÖ Inventario de veh√≠culos cargado exitosamente');
    console.log(`üìã Total veh√≠culos: ${inventoryTest.totalVehicles}`);
    console.log(`üñºÔ∏è Veh√≠culos con im√°genes: ${inventoryTest.hasImages ? 'S√≠' : 'No'}`);
  } else {
    console.log('‚ö†Ô∏è Error cargando inventario:', inventoryTest.error);
  }
  
  // Verificar Google Sheets para leads
  console.log('üìä Verificando conexi√≥n a Google Sheets...');
  const sheetsTest = await vehicleSheetsService.testConnection();
  if (sheetsTest.success) {
    console.log('‚úÖ Google Sheets conectado exitosamente');
    console.log(`üìã Spreadsheet: ${sheetsTest.title}`);
  } else {
    console.log('‚ö†Ô∏è Google Sheets no disponible:', sheetsTest.error);
  }
  
  // Verificar Google Cloud Storage
  console.log('‚òÅÔ∏è Verificando conexi√≥n a Google Cloud Storage...');
  const gcsTest = await gcsService.testConnection();
  if (gcsTest.success) {
    console.log('‚úÖ Google Cloud Storage conectado exitosamente');
    console.log(`üìÅ Bucket: ${gcsTest.bucket}/${gcsTest.folder}`);
  } else {
    console.log('‚ö†Ô∏è Google Cloud Storage no disponible:', gcsTest.error);
  }
})();

// Nueva funci√≥n para enviar texto
async function sendWhatsAppText(to, message) {
  try {
    const response = await axios.post(`${ULTRAMSG_BASE_URL}/messages/chat`, {
      token: ULTRAMSG_TOKEN,
      to: to,
      body: message
    });
    
    logConversation(to, message, 'bot');
    return response.data;
  } catch (error) {
    console.error('Error enviando mensaje de texto:', error.response?.data || error.message);
    throw error;
  }
}

// Nueva funci√≥n para enviar audio
async function sendWhatsAppAudio(to, filePath, fileName) {
  try {
    const fs = require('fs');
    const FormData = require('form-data');
    
    // Crear FormData para enviar el archivo
    const form = new FormData();
    form.append('token', ULTRAMSG_TOKEN);
    form.append('to', to);
    form.append('audio', fs.createReadStream(filePath), {
      filename: fileName,
      contentType: 'audio/mpeg'
    });
    
    const response = await axios.post(`${ULTRAMSG_BASE_URL}/messages/audio`, form, {
      headers: {
        ...form.getHeaders(),
      },
      timeout: 60000 // 1 minuto timeout para archivos
    });
    
    console.log(`üîä Audio enviado a ${to}: ${fileName}`);
    return response.data;
  } catch (error) {
    console.error('Error enviando audio:', error.response?.data || error.message);
    throw error;
  }
}

// Nueva funci√≥n para enviar audio por URL
async function sendWhatsAppAudioByUrl(to, audioUrl) {
  try {
    const response = await axios.post(`${ULTRAMSG_BASE_URL}/messages/audio`, {
      token: ULTRAMSG_TOKEN,
      to: to,
      audio: audioUrl
    });
    
    console.log(`üîä Audio por URL enviado a ${to}: ${audioUrl}`);
    return response.data;
  } catch (error) {
    console.error('Error enviando audio por URL:', error.response?.data || error.message);
    throw error;
  }
}

// Funci√≥n para enviar mensaje por WhatsApp (actualizada para usar an√°lisis de tono)
async function sendWhatsAppMessage(to, message, options = {}) {
  try {
    const sendAsAudio = options.sendAsAudio !== false && process.env.ENABLE_AUDIO_MESSAGES === 'true';
    
    if (sendAsAudio) {
      console.log(`üéôÔ∏è Generando audio para ${to}...`);
      
      // Analizar el tono del mensaje para configuraci√≥n √≥ptima
      const analyzedTone = elevenLabsService.analyzeMessageTone(message);
      const voiceConfig = elevenLabsService.getVoiceForMessageType(analyzedTone);
      
      console.log(`üé≠ Tono detectado: ${analyzedTone}`);
      
      const audioResult = await elevenLabsService.textToSpeech(message, voiceConfig);
      
      if (audioResult.success && audioResult.publicUrl) {
        try {
          // Enviar usando la URL p√∫blica de GCS
          const response = await sendWhatsAppAudioByUrl(to, audioResult.publicUrl);
          
          // Programar eliminaci√≥n del archivo despu√©s de 2 horas
          setTimeout(async () => {
            try {
              await gcsService.deleteAudio(audioResult.fileName);
              console.log(`üóëÔ∏è Archivo eliminado de GCS: ${audioResult.fileName}`);
            } catch (e) {
              console.log('No se pudo eliminar archivo de GCS');
            }
          }, 2 * 60 * 60 * 1000); // 2 horas
          
          logConversation(to, `[AUDIO-GCS] ${message}`, 'bot');
          return response;
          
        } catch (audioError) {
          console.log('‚ùå Fall√≥ env√≠o como audio, enviando como texto...');
          
          // Limpiar archivo de GCS si fall√≥ el env√≠o
          try {
            await gcsService.deleteAudio(audioResult.fileName);
          } catch (e) {}
          
          return await sendWhatsAppText(to, message);
        }
      } else if (audioResult.success && audioResult.filePath) {
        // Fallback a m√©todo local si no hay URL p√∫blica
        try {
          const response = await sendWhatsAppAudio(to, audioResult.filePath, audioResult.fileName);
          
          // Limpiar archivo temporal despu√©s de 30 segundos
          setTimeout(() => {
            try {
              const fs = require('fs');
              fs.unlinkSync(audioResult.filePath);
              console.log(`üóëÔ∏è Archivo temporal eliminado: ${audioResult.fileName}`);
            } catch (e) {
              console.log('No se pudo eliminar archivo temporal');
            }
          }, 30000);
          
          logConversation(to, `[AUDIO] ${message}`, 'bot');
          return response;
        } catch (audioError) {
          console.log('‚ùå Fall√≥ env√≠o como audio local, enviando como texto...');
          return await sendWhatsAppText(to, message);
        }
      } else {
        console.log('‚ö†Ô∏è Fallo generaci√≥n de audio, enviando como texto');
        return await sendWhatsAppText(to, message);
      }
    } else {
      return await sendWhatsAppText(to, message);
    }
  } catch (error) {
    console.error('Error en sendWhatsAppMessage:', error);
    return await sendWhatsAppText(to, message);
  }
}

// Funci√≥n para procesar mensajes del usuario
async function processUserMessage(phoneNumber, message, options = {}) {
  try {
    const { isAudioMessage = false, mediaUrl = null } = options;
    
    let finalMessage = message;
    
    // Si es mensaje de audio, transcribir primero
    if (isAudioMessage && mediaUrl) {
      console.log('üé§ Procesando mensaje de audio...');
      const transcription = await transcriptionService.transcribeAudio(mediaUrl);
      
      if (transcription.success) {
        finalMessage = transcription.text;
        console.log(`üìù Audio transcrito: "${finalMessage}"`);
      } else {
        // Si falla la transcripci√≥n, responder pidiendo texto
        return {
          success: true,
          response: {
            type: 'transcription_error',
            message: transcription.fallbackMessage || 'No pude entender el audio, ¬øpuedes escribirme qu√© necesitas?',
            waitingFor: 'consulta_general',
            shouldRespondWithAudio: false // Forzar respuesta en texto
          }
        };
      }
    }
    
    logConversation(phoneNumber, finalMessage, 'user');
    
    let leadData = await vehicleDB.findByPhone(phoneNumber);
    
    if (!leadData) {
      // Crear nuevo lead si no existe
      leadData = await vehicleDB.create({
        cliente: {
          celular: phoneNumber,
          nombre: 'Cliente Potencial',
          fecha_inicial_contacto: new Date()
        },
        interes: {},
        proceso: {
          step_actual: 'saludo_inicial',
          status: 'activo',
          conversacion_historial: []
        }
      });
    }
    
    // Guardar informaci√≥n sobre el tipo de mensaje
    leadData.lastUserMessage = finalMessage;
    leadData.lastMessageWasAudio = isAudioMessage;
    
    // Procesar mensaje con el motor conversacional
    const response = await vehicleConversationEngine.processResponse(finalMessage, leadData);
    
    // Determinar si responder con audio
    response.shouldRespondWithAudio = isAudioMessage; // Responder en el mismo formato
    
    // Actualizar base de datos
    const updateData = {
      interes: {
        ...leadData.interes,
        ...response.extractedData
      },
      proceso: {
        ...leadData.proceso,
        step_actual: response.waitingFor || leadData.proceso.step_actual,
        ultima_actividad: new Date(),
        conversacion_historial: response.extractedData?.conversacion_historial || leadData.proceso.conversacion_historial
      }
    };
    
    // Manejar diferentes tipos de respuesta
    if (response.type === 'appointment_confirmed') {
      updateData.proceso.status = 'cita_agendada';
      updateData.proceso.fecha_cita = response.appointmentDate;
      
      // Enviar notificaci√≥n por email
      setTimeout(async () => {
        try {
          const finalLeadData = await vehicleDB.findByPhone(phoneNumber);
          const emailResult = await emailService.sendAppointmentNotification(finalLeadData);
          if (emailResult.success) {
            console.log(`üìß Email de cita enviado: ${emailResult.id}`);
          }
          
          // Registrar en Google Sheets
          const sheetsResult = await vehicleSheetsService.addLeadToSheet(finalLeadData);
          if (sheetsResult.success) {
            console.log(`üìä Lead registrado en Google Sheets`);
          }
        } catch (error) {
          console.error('‚ùå Error en proceso post-cita:', error);
        }
      }, 2000);
      
      console.log(`üìÖ Cita agendada exitosamente: ${phoneNumber}`);
    }
    
    await vehicleDB.update(phoneNumber, updateData);
    
    return {
      success: true,
      response: response
    };
    
  } catch (error) {
    console.error('Error procesando mensaje:', error);
    
    // Manejo especial para errores de Claude overloaded
    if (error.message && error.message.includes('overloaded')) {
      const fallbackResponses = [
        "Uy parcero, se me colg√≥ el sistema un momentito üòÖ ¬øMe puedes repetir lo que me dijiste?",
        "Ay no, se me fue la conexi√≥n por un segundo. ¬øQu√© me estabas comentando?",
        "Perd√≥n, el internet est√° medio loco hoy. ¬øMe vuelves a decir qu√© necesitas?",
        "Disculpa la demora, se me trab√≥ todo ac√°. ¬øCu√°l era tu pregunta?"
      ];
      
      const randomResponse = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
      
      return {
        success: true,
        response: {
          type: 'error_natural',
          message: randomResponse,
          waitingFor: 'consulta_general',
          shouldRespondWithAudio: false
        }
      };
    }
    
    // Otros errores
    const naturalErrorResponses = [
      "Oye, se me complic√≥ algo ac√° en el sistema. ¬øPodr√≠as decirme de nuevo qu√© necesitas?",
      "Perd√≥n, parece que hubo un problemita t√©cnico. ¬øMe repites por favor?",
      "Ay, se me fue todo por un momento. ¬øQu√© me estabas preguntando?",
      "Disculpa, tuve una falla ac√°. ¬øMe cuentas otra vez qu√© andas buscando?"
    ];
    
    const randomErrorResponse = naturalErrorResponses[Math.floor(Math.random() * naturalErrorResponses.length)];
    
    return {
      success: false,
      message: randomErrorResponse
    };
  }
}

// Webhook para recibir mensajes de WhatsApp
app.post('/webhook', async (req, res) => {
  try {
    console.log('Webhook recibido:', JSON.stringify(req.body, null, 2));
    
    const { data } = req.body;
    
    if (data && data.from) {
      
      if (data.fromMe === true || data.self === true) {
        console.log('üì§ Ignorando mensaje del bot mismo');
        res.status(200).json({ success: true });
        return;
      }
      
      if (req.body.event_type === 'message_ack') {
        console.log('üì¨ Ignorando ACK');
        res.status(200).json({ success: true });
        return;
      }
      
      if (req.body.event_type !== 'message_received') {
        console.log('üìù Ignorando evento:', req.body.event_type);
        res.status(200).json({ success: true });
        return;
      }
      
      const userMessage = data.body ? data.body.trim() : '';
      const phoneNumber = formatPhoneNumber(data.from);
      const messageType = data.type;
      const mediaUrl = data.media;
      
      const isAudioMessage = messageType === 'ptt' || messageType === 'audio';
      
      // Verificar si el n√∫mero est√° autorizado
      if (!AUTHORIZED_NUMBERS.includes(phoneNumber)) {
        console.log(`üö´ N√öMERO NO AUTORIZADO: ${phoneNumber}`);
        res.status(200).json({ success: true, message: 'N√∫mero no autorizado' });
        return;
      }
      
      if (isAudioMessage && mediaUrl) {
        console.log(`üéôÔ∏è MENSAJE DE AUDIO de ${phoneNumber}: ${mediaUrl}`);
      } else if (userMessage) {
        console.log(`üì± MENSAJE DE TEXTO de ${phoneNumber}: ${userMessage}`);
      } else {
        console.log(`üì≠ MENSAJE VAC√çO de ${phoneNumber}`);
        res.status(200).json({ success: true });
        return;
      }
      
      // Verificar si hay una conversaci√≥n activa
      let conversation = activeConversations.get(phoneNumber) || {
        messages: [],
        lastActivity: new Date(),
        isProcessing: false
      };
      
      // Agregar mensaje a la cola
      conversation.messages.push({
        text: userMessage,
        isAudio: isAudioMessage,
        mediaUrl: mediaUrl,
        timestamp: new Date()
      });
      
      conversation.lastActivity = new Date();
      activeConversations.set(phoneNumber, conversation);
      
      // Si no se est√° procesando, procesar inmediatamente
      if (!conversation.isProcessing) {
        conversation.isProcessing = true;
        
        setTimeout(async () => {
          try {
            const conv = activeConversations.get(phoneNumber);
            if (conv && conv.messages.length > 0) {
              // Tomar el √∫ltimo mensaje
              const lastMessage = conv.messages[conv.messages.length - 1];
              conv.messages = []; // Limpiar mensajes procesados
              
              // Procesar mensaje
              const result = await processUserMessage(phoneNumber, lastMessage.text, {
                isAudioMessage: lastMessage.isAudio,
                mediaUrl: lastMessage.mediaUrl
              });
              
              if (result.success) {
                const shouldUseAudio = result.response.shouldRespondWithAudio !== false;
                
                // Manejar env√≠o de im√°genes
                if (result.response.type === 'send_images') {
                  // Primero enviar el mensaje de texto
                  await sendWhatsAppMessage(phoneNumber, result.response.message, {
                    messageType: 'product_info',
                    sendAsAudio: shouldUseAudio
                  });
                  
                  // Luego enviar im√°genes si hay referencia de veh√≠culo
                  if (result.response.vehicleReference) {
                    const vehicle = await inventoryService.getVehicleByReference(result.response.vehicleReference);
                    if (vehicle && vehicle.ImagenesArray) {
                      const imageResult = await imageService.sendVehicleImages(phoneNumber, vehicle, 3);
                      if (imageResult.success) {
                        console.log(`üì∏ ${imageResult.totalSent} im√°genes enviadas del ${vehicle.Marca} ${vehicle.Modelo}`);
                      } else {
                        // Si falla el env√≠o de im√°genes, informar al usuario
                        await sendWhatsAppMessage(phoneNumber, "Uy, tuve problemas enviando las fotos. ¬øTe parece si me escribes y te cuento m√°s detalles?", {
                          messageType: 'error',
                          sendAsAudio: false
                        });
                      }
                    } else {
                      // Si no hay referencia espec√≠fica, preguntar cu√°l veh√≠culo
                      await sendWhatsAppMessage(phoneNumber, "¬øDe cu√°l veh√≠culo quieres ver las fotos? P√°same la referencia.", {
                        messageType: 'consultation',
                        sendAsAudio: shouldUseAudio
                      });
                    }
                  } else {
                    // Si no hay referencia espec√≠fica, preguntar cu√°l veh√≠culo
                    await sendWhatsAppMessage(phoneNumber, "¬øDe cu√°l veh√≠culo quieres ver las fotos? P√°same la referencia.", {
                      messageType: 'consultation',
                      sendAsAudio: shouldUseAudio
                    });
                  }
                } else {
                  // Manejo normal de otros tipos de respuesta
                  await sendWhatsAppMessage(phoneNumber, result.response.message, {
                    messageType: result.response.type === 'appointment_confirmed' ? 'appointment' : 'product_info',
                    sendAsAudio: shouldUseAudio
                  });
                }
                
                if (result.response.type === 'appointment_confirmed') {
                  console.log(`üéâ ¬°CITA AGENDADA! ${phoneNumber}`);
                }
              } else {
                await sendWhatsAppMessage(phoneNumber, result.message, {
                  messageType: 'error',
                  sendAsAudio: false // Errores siempre en texto
                });
              }
              
              conv.isProcessing = false;
              activeConversations.set(phoneNumber, conv);
            }
          } catch (error) {
            console.error('Error procesando conversaci√≥n:', error);
            const conv = activeConversations.get(phoneNumber);
            if (conv) {
              conv.isProcessing = false;
              activeConversations.set(phoneNumber, conv);
            }
            
            try {
              const naturalErrorResponses = [
                "Uy, se me complic√≥ algo ac√°. ¬øPodr√≠as intentar nuevamente?",
                "Ay perd√≥n, se me trab√≥ todo. ¬øMe vuelves a escribir?",
                "Disculpa, tuve un problemita t√©cnico. ¬øMe repites por favor?"
              ];
              
              const randomResponse = naturalErrorResponses[Math.floor(Math.random() * naturalErrorResponses.length)];
              await sendWhatsAppMessage(phoneNumber, randomResponse, {
                messageType: 'error',
                sendAsAudio: false
              });
            } catch (sendError) {
              console.error('Error enviando mensaje de error:', sendError);
            }
          }
        }, 1000); // Reducir delay a 1 segundo
      }
    }
    
    res.status(200).json({ success: true });
  } catch (error) {
    console.error('Error en webhook:', error);
    res.status(500).json({ error: 'Error procesando webhook' });
  }
});

// Endpoint para simular inicio de conversaci√≥n (sin formulario)
app.post('/start-conversation', async (req, res) => {
  try {
    const { phoneNumber } = req.body;
    
    if (!phoneNumber) {
      return res.status(400).json({ error: 'N√∫mero de tel√©fono requerido' });
    }
    
    const normalizedPhone = formatPhoneNumber(phoneNumber);
    
    // Verificar que sea un n√∫mero autorizado
    if (!AUTHORIZED_NUMBERS.includes(normalizedPhone)) {
      console.log(`üö´ CONVERSACI√ìN RECHAZADA: N√∫mero ${normalizedPhone} no autorizado`);
      return res.status(403).json({ 
        error: 'N√∫mero no autorizado', 
        authorizedNumbers: AUTHORIZED_NUMBERS 
      });
    }
    
    // Crear registro en base de datos
    const leadData = await vehicleDB.create({
      cliente: {
        celular: normalizedPhone,
        nombre: 'Cliente Potencial',
        fecha_inicial_contacto: new Date()
      },
      interes: {},
      proceso: {
        step_actual: 'saludo_inicial',
        status: 'activo',
        conversacion_historial: []
      }
    });
    
    console.log(`üíæ Lead creado con ID: ${leadData.id} para n√∫mero: ${normalizedPhone}`);
    
    // Obtener inventario para mensaje personalizado
    const inventory = await inventoryService.getInventory();
    
    // Mensaje inicial m√°s natural y personalizado (CORTO)
    const initialMessage = `¬°Ey! ¬øQu√© tal? Soy Carlos del concesionario üëã

¬øAndas buscando carro?`;

    await sendWhatsAppMessage(normalizedPhone, initialMessage, { 
      messageType: 'greeting',
      sendAsAudio: true 
    });
    
    res.json({ 
      success: true, 
      message: 'Conversaci√≥n iniciada exitosamente',
      leadId: leadData.id,
      phoneNumber: normalizedPhone,
      authorized: true
    });
    
  } catch (error) {
    console.error('Error iniciando conversaci√≥n:', error);
    res.status(500).json({ error: 'Error iniciando conversaci√≥n' });
  }
});

// Endpoints administrativos
app.get('/leads', async (req, res) => {
  try {
    const allLeads = await vehicleDB.getAll();
    const leads = allLeads.map(lead => ({
      id: lead.id,
      cliente: lead.cliente?.nombre || 'Cliente Potencial',
      telefono: lead.cliente?.celular,
      interes: {
        marca: lead.interes?.marca_interes || 'No especificado',
        tipo: lead.interes?.tipo_vehiculo || 'No especificado',
        presupuesto: lead.interes?.presupuesto_max || 'No especificado'
      },
      status: lead.proceso?.status || 'indefinido',
      ultima_actividad: lead.proceso?.ultima_actividad,
      fecha_inicio: lead.proceso?.fecha_inicio || lead.cliente?.fecha_inicial_contacto,
      fecha_cita: lead.proceso?.fecha_cita,
      autorizado: AUTHORIZED_NUMBERS.includes(lead.cliente?.celular),
      conversaciones: lead.proceso?.conversacion_historial?.length || 0
    }));
    
    res.json({ 
      leads, 
      total: leads.length,
      authorizedNumbers: AUTHORIZED_NUMBERS,
      authorizedLeads: leads.filter(l => l.autorizado).length,
      activeLeads: leads.filter(l => l.status === 'activo').length,
      appointmentScheduled: leads.filter(l => l.status === 'cita_agendada').length
    });
  } catch (error) {
    console.error('Error obteniendo leads:', error);
    res.status(500).json({ error: 'Error obteniendo leads' });
  }
});

app.get('/inventory', async (req, res) => {
  try {
    const inventory = await inventoryService.getInventory();
    
    if (inventory.success) {
      res.json({
        success: true,
        vehicles: inventory.vehicles,
        total: inventory.vehicles.length,
        brands: inventory.brands,
        models: inventory.models,
        types: inventory.types,
        colors: inventory.colors,
        transmissions: inventory.transmissions
      });
    } else {
      res.status(500).json({
        success: false,
        error: inventory.error
      });
    }
  } catch (error) {
    console.error('Error obteniendo inventario:', error);
    res.status(500).json({ error: 'Error obteniendo inventario' });
  }
});

app.get('/lead/:phone', async (req, res) => {
  try {
    const phoneNumber = formatPhoneNumber(req.params.phone);
    const lead = await vehicleDB.findByPhone(phoneNumber);
    
    if (lead) {
      res.json({
        ...lead,
        authorized: AUTHORIZED_NUMBERS.includes(phoneNumber),
        currentStep: lead.proceso?.step_actual,
        vehiculosInteres: lead.interes?.vehiculos_consultados || [],
        conversationHistory: lead.proceso?.conversacion_historial || []
      });
    } else {
      res.status(404).json({ error: 'Lead no encontrado' });
    }
  } catch (error) {
    console.error('Error obteniendo lead:', error);
    res.status(500).json({ error: 'Error obteniendo lead' });
  }
});

// Limpiar datos de un n√∫mero espec√≠fico
app.delete('/admin/clear-data/:phone', async (req, res) => {
  try {
    const phoneNumber = formatPhoneNumber(req.params.phone);
    
    const deleted = await vehicleDB.delete(phoneNumber);
    activeConversations.delete(phoneNumber);
    
    res.json({
      success: true,
      message: 'Datos limpiados exitosamente',
      phoneNumber: phoneNumber,
      deleted: deleted
    });
  } catch (error) {
    console.error('Error limpiando datos:', error);
    res.status(500).json({ error: 'Error limpiando datos' });
  }
 });
 
 // Endpoint para probar inventario
 app.get('/admin/test-inventory', async (req, res) => {
  try {
    console.log('üß™ Probando conexi√≥n con inventario...');
    
    const testResult = await inventoryService.testConnection();
    
    res.json({
      success: testResult.success,
      message: testResult.success ? 'Inventario cargado exitosamente' : 'Error cargando inventario',
      totalVehicles: testResult.totalVehicles || 0,
      brands: testResult.brands || [],
      types: testResult.types || [],
      hasImages: testResult.hasImages || false,
      error: testResult.error || null
    });
    
  } catch (error) {
    console.error('Error probando inventario:', error);
    res.status(500).json({ error: 'Error probando inventario' });
  }
 });
 
 // Endpoint para probar GCS
 app.get('/admin/test-gcs', async (req, res) => {
  try {
    const testResult = await gcsService.testConnection();
    res.json(testResult);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
 });
 
 // Endpoint para listar audios en GCS
 app.get('/admin/gcs-audios', async (req, res) => {
  try {
    const result = await gcsService.listAudios();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
 });
 
 // Endpoint para limpiar audios antiguos
 app.post('/admin/clean-gcs-audios', async (req, res) => {
  try {
    const { maxAgeHours = 24 } = req.body;
    const result = await gcsService.cleanOldAudios(maxAgeHours);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
 });
 
 // Endpoint para ajustar configuraci√≥n de voz
 app.post('/admin/voice-config', async (req, res) => {
  try {
    const { voiceId, stability, similarity_boost, style } = req.body;
    
    if (voiceId) {
      elevenLabsService.setVoice(voiceId);
    }
    
    if (stability !== undefined || similarity_boost !== undefined || style !== undefined) {
      const newSettings = {};
      if (stability !== undefined) newSettings.stability = stability;
      if (similarity_boost !== undefined) newSettings.similarity_boost = similarity_boost;
      if (style !== undefined) newSettings.style = style;
      
      elevenLabsService.updateVoiceSettings(newSettings);
    }
    
    res.json({
      success: true,
      message: 'Configuraci√≥n de voz actualizada',
      currentVoice: elevenLabsService.defaultVoiceId,
      currentSettings: elevenLabsService.voiceSettings
   });
 } catch (error) {
   res.status(500).json({ error: error.message });
 }
 });
 
 // Endpoint para probar calidad de voz
 app.post('/admin/test-voice', async (req, res) => {
 try {
   const { text, messageType } = req.body;
   
   const testText = text || "¬°Hola! Esta es una prueba de la voz mejorada de Carlos. ¬øSe escucha natural y menos rob√≥tica?";
   const analyzedTone = elevenLabsService.analyzeMessageTone(testText);
   const finalMessageType = messageType || analyzedTone;
   
   console.log(`üé≠ Probando voz con tono: ${finalMessageType}`);
   
   const voiceConfig = elevenLabsService.getVoiceForMessageType(finalMessageType);
   const result = await elevenLabsService.textToSpeech(testText, voiceConfig);
   
   if (result.success) {
     // Programar eliminaci√≥n despu√©s de 10 minutos
     setTimeout(async () => {
       try {
         await gcsService.deleteAudio(result.fileName);
       } catch (e) {
         console.log('No se pudo eliminar archivo de prueba');
       }
     }, 10 * 60 * 1000);
   }
   
   res.json({
     success: result.success,
     audioUrl: result.publicUrl,
     detectedTone: analyzedTone,
     usedTone: finalMessageType,
     voiceSettings: voiceConfig.voiceSettings,
     text: testText,
     error: result.error
   });
 } catch (error) {
   res.status(500).json({ error: error.message });
 }
 });
 
 // Endpoint para obtener configuraci√≥n actual de voz
 app.get('/admin/voice-config', (req, res) => {
 try {
   res.json({
     success: true,
     currentVoice: elevenLabsService.defaultVoiceId,
     currentSettings: elevenLabsService.voiceSettings,
     availableTones: [
       'greeting',
       'product_info', 
       'appointment',
       'error',
       'enthusiasm',
       'consultation'
     ]
   });
 } catch (error) {
   res.status(500).json({ error: error.message });
 }
 });
 
 // Endpoint para probar env√≠o de im√°genes
 app.post('/admin/test-images', async (req, res) => {
  try {
    const { phoneNumber, vehicleReference } = req.body;
    
    if (!phoneNumber) {
      return res.status(400).json({ error: 'N√∫mero de tel√©fono requerido' });
    }
    
    const normalizedPhone = formatPhoneNumber(phoneNumber);
    
    if (vehicleReference) {
      // Probar con veh√≠culo espec√≠fico
      const vehicle = await inventoryService.getVehicleByReference(vehicleReference);
      if (!vehicle) {
        return res.status(404).json({ error: 'Veh√≠culo no encontrado' });
      }
      
      const result = await imageService.sendVehicleImages(normalizedPhone, vehicle);
      res.json({
        success: result.success,
        message: `${result.totalSent || 0} im√°genes enviadas`,
        vehicle: {
          referencia: vehicle.Referencia_Vehiculo,
          marca: vehicle.Marca,
          modelo: vehicle.Modelo
        },
        result: result
      });
    } else {
      // Prueba con imagen de demo
      const result = await imageService.testImageSend(normalizedPhone);
      res.json({
        success: result.success,
        message: 'Imagen de prueba enviada',
        result: result
      });
    }
    
  } catch (error) {
    console.error('Error probando im√°genes:', error);
    res.status(500).json({ error: 'Error probando im√°genes' });
  }
 });
 
 // Endpoint para ver conversaciones activas
 app.get('/conversations', (req, res) => {
 const conversations = [];
 activeConversations.forEach((conv, phone) => {
   conversations.push({
     phoneNumber: phone,
     messagesInQueue: conv.messages.length,
     isProcessing: conv.isProcessing,
     lastActivity: conv.lastActivity,
     authorized: AUTHORIZED_NUMBERS.includes(phone)
   });
 });
 
 res.json({ 
   conversations, 
   total: conversations.length,
   authorizedNumbers: AUTHORIZED_NUMBERS
 });
 });
 
 // Endpoint para estad√≠sticas del sistema
 app.get('/stats', async (req, res) => {
 try {
   const leads = await vehicleDB.getAll();
   const inventory = await inventoryService.getInventory();
   
   // Estad√≠sticas de leads
   const leadStats = {
     total: leads.length,
     activos: leads.filter(l => l.proceso?.status === 'activo').length,
     conCita: leads.filter(l => l.proceso?.status === 'cita_agendada').length,
     completados: leads.filter(l => l.proceso?.status === 'completado').length
   };
   
   // Marcas m√°s consultadas
   const marcasConsultadas = {};
   leads.forEach(lead => {
     if (lead.interes?.marca_interes) {
       const marca = lead.interes.marca_interes;
       marcasConsultadas[marca] = (marcasConsultadas[marca] || 0) + 1;
     }
   });
   
   // Inventario stats
   const inventoryStats = inventory.success ? {
     totalVehicles: inventory.vehicles.length,
     brands: inventory.brands.length,
     types: inventory.types ? inventory.types.length : 0,
     withImages: inventory.vehicles.filter(v => v.ImagenesArray && v.ImagenesArray.length > 0).length,
     lastUpdate: inventory.lastUpdate
   } : { totalVehicles: 0, brands: 0, types: 0, withImages: 0, lastUpdate: null };
   
   // Estad√≠sticas de mensajes de audio vs texto
   const audioStats = {
     totalConversations: leads.length,
     conversationsWithAudio: leads.filter(l => 
       l.proceso?.conversacion_historial?.some(conv => conv.was_audio)
     ).length
   };
   
   res.json({
     leads: leadStats,
     inventory: inventoryStats,
     audio: audioStats,
     marcasPopulares: marcasConsultadas,
     conversacionesActivas: activeConversations.size,
     timestamp: new Date().toISOString()
   });
 } catch (error) {
   console.error('Error obteniendo estad√≠sticas:', error);
   res.status(500).json({ error: 'Error obteniendo estad√≠sticas' });
 }
 });
 
 // Health check
 app.get('/health', async (req, res) => {
 try {
   const dbHealth = await vehicleDB.healthCheck();
   const inventoryHealth = await inventoryService.testConnection();
   const gcsHealth = await gcsService.testConnection();
   
   const services = {
     database: {
       redis: dbHealth.redis,
       memory: dbHealth.memory > 0,
       total: dbHealth.total
     },
     inventory: {
       configured: true,
       loaded: inventoryHealth.success,
       totalVehicles: inventoryHealth.totalVehicles || 0,
       hasImages: inventoryHealth.hasImages || false
     },
     email: {
       configured: !!(process.env.RESEND_API_KEY && process.env.DOMAIN),
       ready: !!(process.env.RESEND_API_KEY && process.env.DOMAIN)
     },
     claude: {
       configured: !!process.env.CLAUDE_API_KEY,
       ready: !!process.env.CLAUDE_API_KEY
     },
     ultramsg: {
       configured: !!(process.env.ULTRAMSG_TOKEN && process.env.INSTANCE_ID),
       ready: !!(process.env.ULTRAMSG_TOKEN && process.env.INSTANCE_ID)
     },
     elevenlabs: {
       configured: !!process.env.ELEVENLABS_API_KEY,
       ready: !!process.env.ELEVENLABS_API_KEY,
       currentVoice: elevenLabsService.defaultVoiceId,
       voiceSettings: elevenLabsService.voiceSettings
     },
     gcs: {
       configured: gcsHealth.success,
       ready: gcsHealth.success,
       bucket: gcsHealth.bucket || null,
       folder: gcsHealth.folder || null
     },
     transcription: {
       configured: !!process.env.OPENAI_API_KEY,
       ready: !!process.env.OPENAI_API_KEY
     },
     images: {
       configured: !!(process.env.ULTRAMSG_TOKEN && process.env.INSTANCE_ID),
       ready: !!(process.env.ULTRAMSG_TOKEN && process.env.INSTANCE_ID)
     }
   };
   
   const allServicesReady = Object.values(services).every(service => service.ready || service.loaded);
   
   res.json({ 
     status: allServicesReady ? 'OK' : 'PARTIAL',
     timestamp: new Date().toISOString(),
     activeConversations: activeConversations.size,
     totalLeads: dbHealth.total,
     uptime: process.uptime(),
     authorizedNumbers: AUTHORIZED_NUMBERS,
     environment: process.env.NODE_ENV || 'development',
     services: services,
     version: '2.1-enhanced-images'
   });
 } catch (error) {
   console.error('Error en health check:', error);
   res.status(500).json({ 
     status: 'ERROR',
     error: 'Error en health check',
     timestamp: new Date().toISOString()
   });
 }
 });
 
 // Endpoint para an√°lisis de tono de mensajes
 app.post('/admin/analyze-tone', (req, res) => {
 try {
   const { message } = req.body;
   
   if (!message) {
     return res.status(400).json({ error: 'Mensaje requerido' });
   }
   
   const analyzedTone = elevenLabsService.analyzeMessageTone(message);
   const voiceConfig = elevenLabsService.getVoiceForMessageType(analyzedTone);
   
   res.json({
     success: true,
     message: message,
     detectedTone: analyzedTone,
     voiceConfig: voiceConfig,
     explanation: {
       greeting: "Para saludos c√°lidos y amigables",
       product_info: "Para informaci√≥n de productos balanceada", 
       appointment: "Para confirmaciones de citas entusiastas",
       error: "Para mensajes de error calmados",
       enthusiasm: "Para momentos de emoci√≥n y entusiasmo",
       consultation: "Para consultas t√©cnicas profesionales"
     }[analyzedTone] || "Configuraci√≥n por defecto"
   });
 } catch (error) {
   res.status(500).json({ error: error.message });
 }
 });
 
 // Endpoint para obtener detalles de veh√≠culo con im√°genes
 app.get('/vehicle/:reference', async (req, res) => {
  try {
    const { reference } = req.params;
    const vehicleDetails = await inventoryService.getVehicleDetails(reference);
    
    if (vehicleDetails.success) {
      res.json({
        success: true,
        vehicle: vehicleDetails.vehicle
      });
    } else {
      res.status(404).json({
        success: false,
        error: vehicleDetails.message || 'Veh√≠culo no encontrado'
      });
    }
  } catch (error) {
    console.error('Error obteniendo detalles del veh√≠culo:', error);
    res.status(500).json({ error: 'Error obteniendo detalles del veh√≠culo' });
  }
 });
 
 // Endpoint para estad√≠sticas avanzadas del inventario
 app.get('/inventory/stats', async (req, res) => {
  try {
    const stats = await inventoryService.getInventoryStats();
    
    if (stats.success) {
      res.json({
        success: true,
        stats: stats.stats
      });
    } else {
      res.status(500).json({
        success: false,
        error: stats.error
      });
    }
  } catch (error) {
    console.error('Error obteniendo estad√≠sticas del inventario:', error);
    res.status(500).json({ error: 'Error obteniendo estad√≠sticas del inventario' });
  }
 });
 
 // Limpiar archivos antiguos de GCS cada 6 horas
 setInterval(async () => {
 try {
   await gcsService.cleanOldAudios(6); // Eliminar archivos mayores a 6 horas
 } catch (error) {
   console.error('Error limpiando archivos antiguos de GCS:', error);
 }
 }, 6 * 60 * 60 * 1000);
 
 const PORT = process.env.PORT || 3000;
 app.listen(PORT, () => {
 console.log('\n' + '='.repeat(60));
 console.log('üöó BOT CONCESIONARIO INICIADO EXITOSAMENTE');
 console.log('='.repeat(60));
 console.log(`üåê Servidor: http://localhost:${PORT}`);
 console.log(`üîê N√∫meros autorizados: ${AUTHORIZED_NUMBERS.join(', ')}`);
 console.log('');
 console.log('üìã ENDPOINTS PRINCIPALES:');
 console.log(`üöÄ Iniciar conversaci√≥n: POST ${PORT}/start-conversation`);
 console.log(`üí¨ Webhook WhatsApp: POST ${PORT}/webhook`);
 console.log(`üìä Leads: GET ${PORT}/leads`);
 console.log(`üöó Inventario: GET ${PORT}/inventory`);
 console.log(`üè• Health Check: GET ${PORT}/health`);
 console.log(`üìà Estad√≠sticas: GET ${PORT}/stats`);
 console.log('');
 console.log('üîß ENDPOINTS ADMINISTRATIVOS:');
 console.log(`üóëÔ∏è Limpiar datos: DELETE ${PORT}/admin/clear-data/{phone}`);
 console.log(`üß™ Test inventario: GET ${PORT}/admin/test-inventory`);
 console.log(`‚òÅÔ∏è Test GCS: GET ${PORT}/admin/test-gcs`);
 console.log(`üìÅ Listar audios GCS: GET ${PORT}/admin/gcs-audios`);
 console.log(`üßπ Limpiar audios GCS: POST ${PORT}/admin/clean-gcs-audios`);
 console.log('');
 console.log('üéôÔ∏è ENDPOINTS DE VOZ:');
 console.log(`üéõÔ∏è Configurar voz: POST ${PORT}/admin/voice-config`);
 console.log(`üìä Ver configuraci√≥n: GET ${PORT}/admin/voice-config`);
 console.log(`üé§ Probar voz: POST ${PORT}/admin/test-voice`);
 console.log(`üé≠ Analizar tono: POST ${PORT}/admin/analyze-tone`);
 console.log('');
 console.log('üì∏ ENDPOINTS DE IM√ÅGENES:');
 console.log(`üñºÔ∏è Probar im√°genes: POST ${PORT}/admin/test-images`);
 console.log(`üöó Detalles veh√≠culo: GET ${PORT}/vehicle/{reference}`);
 console.log(`üìä Stats inventario: GET ${PORT}/inventory/stats`);
 console.log('');
 console.log('üéØ BOT PARA COMPRA-VENTA DE VEH√çCULOS v2.1-IMAGES-ENHANCED');
 console.log('üí° Funcionalidades:');
 console.log('   üó£Ô∏è Conversaciones s√∫per naturales con Carlos');
 console.log('   üìã Consulta de inventario desde Google Sheets');
 console.log('   ü§ñ IA conversacional avanzada con Claude');
 console.log('   üìÖ Agendamiento de citas intuitivo');
 console.log('   üìß Notificaciones autom√°ticas por email');
 console.log('   üìä Registro de leads en Google Sheets');
 console.log('   üí¨ Manejo inteligente de errores');
 console.log('   üß† Memoria conversacional');
 console.log('   üéôÔ∏è Mensajes de voz naturales con ElevenLabs');
 console.log('   ‚òÅÔ∏è Almacenamiento de audio en Google Cloud Storage');
 console.log('   üé§ Transcripci√≥n de audios con Whisper');
 console.log('   üîÑ Detecci√≥n autom√°tica de formato de mensaje');
 console.log('   üé≠ An√°lisis de tono autom√°tico para voz natural');
 console.log('   üéõÔ∏è Configuraci√≥n din√°mica de par√°metros de voz');
 console.log('   üîä Respuesta en mismo formato (audio por audio)');
 console.log('   üì∏ Env√≠o autom√°tico de im√°genes de veh√≠culos');
 console.log('   üñºÔ∏è Soporte para m√∫ltiples im√°genes por veh√≠culo');
 console.log('   üéØ Detecci√≥n inteligente de solicitudes de im√°genes');
 console.log('   üìù Captions personalizados para cada imagen');
 console.log('='.repeat(60));
 console.log('üéâ ¬°Listo para conversaciones naturales con audio e im√°genes!');
 console.log('='.repeat(60) + '\n');
 
 // Mostrar configuraci√≥n actual de voz
 console.log('üé§ CONFIGURACI√ìN ACTUAL DE VOZ:');
 console.log(`   Voice ID: ${elevenLabsService.defaultVoiceId}`);
 console.log(`   Stability: ${elevenLabsService.voiceSettings.stability}`);
 console.log(`   Similarity Boost: ${elevenLabsService.voiceSettings.similarity_boost}`);
 console.log(`   Style: ${elevenLabsService.voiceSettings.style}`);
 console.log(`   Speaker Boost: ${elevenLabsService.voiceSettings.use_speaker_boost}`);
 console.log('');
 console.log('üìù PARA MEJORAR LA VOZ:');
 console.log(`   POST ${PORT}/admin/voice-config`);
 console.log('   Body: { "stability": 0.6, "similarity_boost": 0.7, "style": 0.4 }');
 console.log('');
 console.log('üé≠ TONOS DISPONIBLES:');
 console.log('   ‚Ä¢ greeting - Saludos c√°lidos');
 console.log('   ‚Ä¢ product_info - Informaci√≥n balanceada');
 console.log('   ‚Ä¢ appointment - Confirmaciones entusiastas');
 console.log('   ‚Ä¢ error - Mensajes de error calmados');
 console.log('   ‚Ä¢ enthusiasm - Momentos de emoci√≥n');
 console.log('   ‚Ä¢ consultation - Consultas t√©cnicas');
 console.log('');
 console.log('üì∏ COMANDOS DE PRUEBA PARA IM√ÅGENES:');
 console.log(`   curl -X POST ${PORT}/admin/test-images -H "Content-Type: application/json" -d '{"phoneNumber": "3183351733"}'`);
 console.log(`   curl -X POST ${PORT}/admin/test-images -H "Content-Type: application/json" -d '{"phoneNumber": "3183351733", "vehicleReference": "VEH001"}'`);
 console.log('='.repeat(60) + '\n');
 });